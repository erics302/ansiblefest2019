---
# This playbook is called if the epg_name var, which is what we get from the cherwell form download, is a vip.
# ACI_contract isn't away of VIPs, nor can a contract be applied to a VIP.  We need to find the matching EPG for the VIP.
# Once we know the EPG for the VIP, we can pass that back in the return_val_epg variable used by the parent playbook ap_epg_query.yml and allow aci_contract to continue as it would for any EPG.

- name: Take the epg_name var, "{{ epg_name }}" and reformat to match the CSV file generated by the palo_address_object_export_role
  set_fact:
    epg_name_search_string: "{{ epg_name|regex_replace(epg_name.split('_')[0]+'_',epg_name.split('_')[0]+',') }}"

- name: Now find "{{ epg_name_search_string }}" in the netinventory.csv file.
  set_fact:
    result: "{{ item }}"
  with_lines: cat "{{ palo_csv_export_file }}"
  when: item is search(epg_name_search_string)
  # netinventory file is the address_object_export roles output; it's CSV formatted.

- name: Extract VIP ip from csv string "{{ result }}"
  set_fact:
    virtual_ip: "{{ result | regex_replace(epg_name_search_string+',', '') }}"

- name: ipaddr search 2
  set_fact:
    epg_containing_vip: "{{ item.bd_name }}"
  loop: "{{ aci_subnet }}"
  when: virtual_ip | ipaddr(item.subnet) == virtual_ip
  # aci_bd_facts role generates a ansible list of dicts representing each bridge_domain/ and EPG subnet (aci_subnet is the name of that list)
  # aci_bd_facts file was included back in main.yml.
  # Use ipaddr to find the subnet and matching EPG name for our virtual_ip.
  # About the when condition: checking an IP address against a subnet will return the ip address if the ip address is a member of the subnet.

- name: Find our exact EPG name {{ epg_name }} if not a VIP.
  set_fact:
    return_val_epg: "{{ item }}"
  when: item | lower() is search(epg_containing_vip | lower())
  with_list: "{{ epg_list_flat }}"
  # We take some values already setup in ap_epg_query for checking non-vips and reuse now that we have an EPG name for the VIP.
  # If we don't find the full proper EPG name we will fail out back in ap_epg_query.yml.
  # return_val_epg is the variable we need, which is an exact EPG name in the fabric, now we can return to ap_epg_query and continue process as if an EPG was requested instead of a VIP.
